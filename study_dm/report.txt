2025/11/25
    Первую задачу можно расширить: сделать функцию, которая читает массив чисел (при том, что чисел там может
    и не быть, и вообще данные могут быть ошибочными) и записывает их в динамический массив целых чисел, 
    затем сортирует и возвращает обратно. 
2025/11/26
    Была исправлена ошибка в условии цикла while(j < str_size && input_str[j] != '\0'). Раньше было
    while(j < str_size && j != '\0'), в то время как на первом шаге цикла j = 0, поэтому цикл ни разу не 
    происходил. Задча выполнена. Проводится попытка решить улучшенную задачу: прочитать массив чисел, вводимых
    пользователем (и разделенных каким нибудь символом), затем отсортировать в порядке неубывания, удалить
    повторяющиеся числа и вывести пользователю.
2025/11/27
    Получилось использовать чтение строковой последовательноти и преобразовать в массив чисел, однако 
    пока без сортировки. Быстро была найдена ошибка, что последнее число не записывалось. После добавления
    проверки на нуль-терминатор if (data_char[i] == symbol || data_char[i] == '\0') ошика исправилась.
2025/11/29
    Успешно выполнена вторая задача. Внутри функции можно выделить память, там же заполнить массив и вернуть 
    указатель на получившееся (см. функцию dup()). 
2025/11/30
    Третья задача успешно выполнена. Необходимо освобождать память, даже если указатель на нее вернула функция.
    Четвертая задача будет несколько усложнена: матрицу будет вводить пользователь вручную.
    Поставленная задача успешно выполнена.
2025/12/02
    Пятая задача теперь делается так: пользователь сам вручную вводит любое количество точек, затем программа
    выдает ему таблицу с расстояниями между ними. Таблица должна быть симметричная с нулями на главной диагонали.
    Однако, таблица выводится неправильно. Необходимо отладить программу.
2025/12/03
    При отладке выяснилось, что счетчик выходил за границы, поэтому были непонятные числа в выводе и 
    несоответствующий размер матрицы. После исправления вывод стал таким, каким задумывался. Пятая задача успешно
    выполнена. Шестая задача уже выполнена и представлена в виде функции read_line().
2025/12/15
    Решение седьмого задания оставило после себя ряд вопросов, оно исполнено в виде функции mem_realloc_basic().
    По поводу восьмой задачи есть сразу несколько предложений:
    1.Пусть команды вводит пользователь в терминал, например: push value - фунция read_line() прочитает 
    последовательность (или даже последовательности) команд и аргументов, затем прочитанная строка будет разрезана
    на части (через пробел), далее команды по очереди выполнятся. 
    2. Пусть добавятся еще две команды get (будет выводить пользователь весь Stack) и pop index (удаляет элемент
    под номером index и возвращает его).
2026/01/19
    Положено начало для обработки строчного ввода приказов. В функции task8_1() будет произведено разбиение вводимой 
    строки на слова через разделительный символ с последующей обработкой каждого слова. Стоит задача: за два месяца
    закончить все 24 задачи и приступить к созданию HTTP-сервера. Подробности задумки изложены в "step1" в корне 
    репозитория.
2026/01/21
    Неудачно разработан алгоритм считывания комманд. Скорей всего использования двойной звездочки при создании массива 
    структур не правильно и следует сделать иначе, кроме того сравнивать массивы символов char двойным равно нельзя.
    Нужно написать свою функцию isequal(char* s1, int s1_size, char* s2, int s2_size), чтобы сравнить два слова, или
    можно использовать библиотечную функцию.
2026/01/22
    Восьмая задача успешно выполнена, однако еще требует доработки:
    1. Не срабатывает выход по символу "q"
    2. Не получается добавить отрицательное число.
2026/01/23
    Восьмая задача успешно выполнена. Исправлена ошибка в функции string_to_int(). Девятую задачу несколько усложним
    для правдоподобности:
        - Время поступления элементов: случайное (Пуассоновский процесс)
        - Время обработки: разное для разных типов элементов
        - Возможность "переполнения" и потери данных
        - Приоритеты: некоторые элементы "пропускают" очередь
    Девятая задача решена лишь на половину (разработана часть с очередью, однако, необходимо подключить потоки, чтобы все 
    работало как задумано). Во-первых, нужно создать простые потоки и посмотреть, как они работают.
2026/01/25
    Переменные static нельзя использовать, если функция будет использована в потоке.
2026/01/26
    Блокировать мьютексом буду только те вещи, которые изменяют обе функции enqueue() и dequeue(). Сведения о течении 
    процесса выводятся лишь дважды, затем программа зависает. Пока не ясно, что ее держит, однако не может не радовать
    что компиляция прошла успешно и очередь запустилась.
2026/01/28
    Как оказалось, очереди работают правильно, однако было неправильно выбрано время задержки.
    Начата десятая задача. Если аргументы функции не будут в ней изменяться, необходимо использовать слово const. Нужно 
    попробовать в функции add_person() и create_person() и освободить нулевой указатель.
2026/01/31
    Успешно выполнена десятая задача. 
2026/02/01
    Почти закончено десятое задание. Оказывается, переменная NULL определена, как ((void*)0). realloc() уместно 
    использовать, даже если новый и старый размеры одинаковы (в таком случае вернется указатель на старую память).
2026/02/02
    Сначала не были инициалицированы поля size и capacity, поэтому динамическая память дала сбой (capacity - большое 
    число), однако благодаря AddressSanitizer эта ошибка была выявлена и устранена. Внутри Makefile остались пометки,
    как его включить. Двенадцатая задача почти завершена.
2026/02/11
    Произошла ошибка Segmentation fault из-за того, что неинициализированному указателю выделяется память:
        int* tmp_nums = (int*)realloc(mtx->nums[mtx->rows], (++ mtx->cols)*sizeof(int)); 
        if (tmp_nums == NULL) return;
        mtx->nums[mtx->rows] = tmp_nums;
    Поведение программы будет неопределено, потому что mtx->nums[mtx->rows] еще не существует, точнее по этому адресу
    находится мусор и realloc() не сможет сработать как malloc(), иначе нужен NULL.
    Еще одна ошибка заключалась в том, что в конце функции add_line_to_matrix() не был установлен флаг init_params = true,
    поэтому число строк в двумерном массиве не увеличивалось.
    Еще одна ошибка заключалась в том, что после исправления первой строкаmtx->nums[mtx->rows] = tmp_nums не была
    исправлена. Теперь mtx->nums[mtx->rows - 1] = tmp_nums.
    Видимо, это еще не все. Работа продолжается.
2026/02/15
    Успешно завершена 12я задача. Была еще одна ошибка, связанная с размером mtx->rows. Еще не было освобождено хранилище 
    strnum в функии add_line_to_matrix().
2026/02/16
    Успешно завершена 13я задача.
2026/02/24
    Задача 14 выполнена в виде функции cutting_string(), за исключением того, что в ней нет обработки нескольких
    разделительных символов, идущих подряд. Начата работа с 16ой задачей.
