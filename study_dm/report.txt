2025/11/25
    Первую задачу можно расширить: сделать функцию, которая читает массив чисел (при том, что чисел там может
    и не быть, и вообще данные могут быть ошибочными) и записывает их в динамический массив целых чисел, 
    затем сортирует и возвращает обратно. 
2025/11/26
    Была исправлена ошибка в условии цикла while(j < str_size && input_str[j] != '\0'). Раньше было
    while(j < str_size && j != '\0'), в то время как на первом шаге цикла j = 0, поэтому цикл ни разу не 
    происходил. Задча выполнена. Проводится попытка решить улучшенную задачу: прочитать массив чисел, вводимых
    пользователем (и разделенных каким нибудь символом), затем отсортировать в порядке неубывания, удалить
    повторяющиеся числа и вывести пользователю.
2025/11/27
    Получилось использовать чтение строковой последовательноти и преобразовать в массив чисел, однако 
    пока без сортировки. Быстро была найдена ошибка, что последнее число не записывалось. После добавления
    проверки на нуль-терминатор if (data_char[i] == symbol || data_char[i] == '\0') ошика исправилась.
2025/11/29
    Успешно выполнена вторая задача. Внутри функции можно выделить память, там же заполнить массив и вернуть 
    указатель на получившееся (см. функцию dup()). 
2025/11/30
    Третья задача успешно выполнена. Необходимо освобождать память, даже если указатель на нее вернула функция.
    Четвертая задача будет несколько усложнена: матрицу будет вводить пользователь вручную.
    Поставленная задача успешно выполнена.
2025/12/02
    Пятая задача теперь делается так: пользователь сам вручную вводит любое количество точек, затем программа
    выдает ему таблицу с расстояниями между ними. Таблица должна быть симметричная с нулями на главной диагонали.
    Однако, таблица выводится неправильно. Необходимо отладить программу.
2025/12/03
    При отладке выяснилось, что счетчик выходил за границы, поэтому были непонятные числа в выводе и 
    несоответствующий размер матрицы. После исправления вывод стал таким, каким задумывался. Пятая задача успешно
    выполнена. Шестая задача уже выполнена и представлена в виде функции read_line().
2025/12/15
    Решение седьмого задания оставило после себя ряд вопросов, оно исполнено в виде функции mem_realloc_basic().
    По поводу восьмой задачи есть сразу несколько предложений:
    1.Пусть команды вводит пользователь в терминал, например: push value - фунция read_line() прочитает 
    последовательность (или даже последовательности) команд и аргументов, затем прочитанная строка будет разрезана
    на части (через пробел), далее команды по очереди выполнятся. 
    2. Пусть добавятся еще две команды get (будет выводить пользователь весь Stack) и pop index (удаляет элемент
    под номером index и возвращает его).
2026/01/19
    Положено начало для обработки строчного ввода приказов. В функции task8_1() будет произведено разбиение вводимой 
    строки на слова через разделительный символ с последующей обработкой каждого слова. Стоит задача: за два месяца
    закончить все 24 задачи и приступить к созданию HTTP-сервера. Подробности задумки изложены в "step1" в корне 
    репозитория.
2026/01/21
    Неудачно разработан алгоритм считывания комманд. Скорей всего использования двойной звездочки при создании массива 
    структур не правильно и следует сделать иначе, кроме того сравнивать массивы символов char двойным равно нельзя.
    Нужно написать свою функцию isequal(char* s1, int s1_size, char* s2, int s2_size), чтобы сравнить два слова, или
    можно использовать библиотечную функцию.
2026/01/22
    Восьмая задача успешно выполнена, однако еще требует доработки:
    1. Не срабатывает выход по символу "q"
    2. Не получается добавить отрицательное число.
2026/01/23
    Восьмая задача успешно выполнена. Исправлена ошибка в функции string_to_int(). Девятую задачу несколько усложним
    для правдоподобности:
        - Время поступления элементов: случайное (Пуассоновский процесс)
        - Время обработки: разное для разных типов элементов
        - Возможность "переполнения" и потери данных
        - Приоритеты: некоторые элементы "пропускают" очередь
    Девятая задача решена лишь на половину (разработана часть с очередью, однако, необходимо подключить потоки, чтобы все 
    работало как задумано). Во-первых, нужно создать простые потоки и посмотреть, как они работают.
