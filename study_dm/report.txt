2025/11/25
    Первую задачу можно расширить: сделать функцию, которая читает массив чисел (при том, что чисел там может
    и не быть, и вообще данные могут быть ошибочными) и записывает их в динамический массив целых чисел, 
    затем сортирует и возвращает обратно. 
2025/11/26
    Была исправлена ошибка в условии цикла while(j < str_size && input_str[j] != '\0'). Раньше было
    while(j < str_size && j != '\0'), в то время как на первом шаге цикла j = 0, поэтому цикл ни разу не 
    происходил. Задча выполнена. Проводится попытка решить улучшенную задачу: прочитать массив чисел, вводимых
    пользователем (и разделенных каким нибудь символом), затем отсортировать в порядке неубывания, удалить
    повторяющиеся числа и вывести пользователю.
2025/11/27
    Получилось использовать чтение строковой последовательноти и преобразовать в массив чисел, однако 
    пока без сортировки. Быстро была найдена ошибка, что последнее число не записывалось. После добавления
    проверки на нуль-терминатор if (data_char[i] == symbol || data_char[i] == '\0') ошика исправилась.
2025/11/29
    Успешно выполнена вторая задача. Внутри функции можно выделить память, там же заполнить массив и вернуть 
    указатель на получившееся (см. функцию dup()). 
