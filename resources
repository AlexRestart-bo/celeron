1. Ядро Linux (образец индустриального кода)

    GitHub: https://github.com/torvalds/linux

    Что смотреть:

        kernel/ — планировщик, системные вызовы

        fs/ — файловые системы

        net/ — сетевая подсистема

        drivers/ — драйверы устройств

    Примеры: Очереди (kernel/workqueue.c), мьютексы, списки

2. Redis (чистый C, отличная архитектура)

    GitHub: https://github.com/redis/redis

    Что смотреть:

        src/ — вся реализация

        Структуры данных: dict.c, adlist.c (списки), ziplist.c

        Сеть: ae.c (event loop), networking.c

        Особенно: Как обрабатываются клиентские запросы, пулы потоков

3. nginx (высокопроизводительный сервер)

    GitHub: https://github.com/nginx/nginx

    Что смотреть:

        Event-driven архитектура

        Работа с памятью (пулы)

        Обработка HTTP

    Сложно для новичка, но показывает мастерство

4. SQLite (компактная БД)

    Сайт: https://sqlite.org/src

    Что смотреть:

        Отличная документация в комментариях

        Чистый, переносимый код

        Тестирование (test/)

5. Проекты от GNU

    glibc (стандартная библиотека): https://sourceware.org/git/?p=glibc.git

    coreutils (базовые утилиты): https://github.com/coreutils/coreutils

    Смотреть: Реализация стандартных функций

6. Меньшие, но качественные проекты
libevent (библиотека событий)

    GitHub: https://github.com/libevent/libevent

    Показывает: Асинхронное программирование, кросс-платформенность

curl (HTTP-клиент)

    GitHub: https://github.com/curl/curl

    Показывает: Работу с сетью, API дизайн

tmux (терминальный мультиплексор)

    GitHub: https://github.com/tmux/tmux

    Показывает: Работу с терминалом, управление процессами

7. Специально для изучения алгоритмов/структур данных
CCAN (Collected C Algorithms)

    Сайт: https://ccodearchive.net/

    Коллекция чистых реализаций алгоритмов на C

klib (легковесные алгоритмы)

    GitHub: https://github.com/attractivechaos/klib

    Хорошо написанные хэш-таблицы, сортировки, строки

Как изучать профессиональный код:
Метод 1: "Вертикальный срез"

    Возьмите одну функцию (например, queue_push)

    Проследите всю цепочку вызовов

    Понимайте инварианты и предусловия

Метод 2: "Поиск паттернов"

    Ищите как решают конкретную проблему (очереди, синхронизация)

    Сравните несколько реализаций в разных проектах

    Выделите общие принципы

Метод 3: "Читать коммиты"

    Смотрите историю изменений конкретного файла

    Понимайте почему изменили код

    Читайте комментарии к коммитам

Конкретно для вашей задачи (очереди, потоки):
В Linux ядре:
text

linux/kernel/workqueue.c     # Система очередей работ
linux/kernel/sched/          # Планировщик (очереди потоков)
linux/include/linux/list.h   # Реализация двусвязных списков

В Redis:
text

redis/src/ae.c               # Event loop (обработка событий)
redis/src/networking.c       # Очереди клиентских запросов
redis/src/adlist.c           # Реализация списков

В libevent:
text

libevent/event.c             # Базовая структура события
libevent/evthread.c          # Поддержка потоков

Инструменты для изучения:

    ctags / cscope — навигация по большому коду

    grep -r "pthread_create" — найти использование pthread

    Git blame — кто и когда написал код

    Doxygen — генерация документации

Что обращать внимание:

    Обработка ошибок — как проверяют возвращаемые значения

    Стиль именования — консистентность

    Комментарии — что объясняют, а что нет

    Макросы и инлайн-функции — когда используют

    Модульность — разделение на файлы

Стартовые точки для изучения прямо сейчас:

    Redis adlist.c — 300 строк, отличная реализация двусвязного списка

    Linux list.h — макросы для встраиваемых списков

    klib kqueue.h — простая очередь

Лучший совет: Возьмите Redis (src/adlist.c и src/ae.c) — код чистый, хорошо прокомментирован, показывает и структуры данных, и асинхронность. Начните с малого — одной структуры, поймите ее полностью, затем двигайтесь дальше.
