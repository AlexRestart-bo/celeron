2026/02/21
    Задача заключается в следующем: написать программу для устройства, которое включает в себя несколько микросхем:
        STM32F103C6T7, SN74LVC4245A, OPA333, LM7805, REF3125, LM2574, LD1117, AD8031, AD5204.
    С инициализацией GPIO и драйвером для дисплея почти закончено. 
2026/02/22
    Пин PB13 отвечает за нагрев топорика, в то время как PB14 и PB15 присоединены к кнопкам. Написана функция милисикундной задержки, использующая SysTick без прерываний.
    Созданы новые функции, структура и глобальные переменные. Основные задачи в настоящее время заключаются в следующем:
        1. По длительному нажатию кнопки должна меняться (и выводиться на дисплее) целевая температура.
        2. Настроить PB13 таким образом, чтобы через DAC менять нагрев плавно.
        3. Написать функцию для рассчета величины нагрева. 
        4. Сделать документацию и написать необходимые комментарии.
2026/02/23
    В настоящем железе нет DAC, поэтому будет использоваться PWM.
2026/02/27
    Нельзя использовать макрос, внутри которого есть глобальная переменная, потому что препроцессор работает до компиляции и не знает ничего о переменных.
    Успешно удалось скомпилировать программу и прошить микроконтроллер, однако (хоть утюжок и греется) числа на дисплее не появляются.
    Следующая задача: отладить программу с помощью arm-none-eabi-gdb и понять причины неполадок. Почему не горит дисплей и не греется топорик.
2026/02/28
    Отладчик не видел файлы-источники и не было возможности поставить внутри них точку остановки. Причина заключалась в том, что не был поставлен флаг
    -g, который позволяет отлаживать программу. Следующей ошибкой было отсутствие явного указание размера стека в Linker Script.
    Чтобы включить отладку в первом терминале нужно ввести st-util -p 4242, а во втором:
        arm-none-eabi-gdb build/firmware.elf
        (gdb) target extended-remote localhost:4242
        (gdb) load
        (gdb) break ...
        (gdb) monitor reset halt 
        (gdb) continue
    Пока что, даже с использованием разных ухищрений не удалось выяснить причину неисправниости программы, однако известно, что сразу после начала функции 
    main вызывается прерывание HardFault_Handler (даже при том условии, что все прерывания были выключены - cpsid i). 
    